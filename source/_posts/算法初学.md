---
layout: post
title: 算法初学
date: 2024-12-19 11:03:03
tags:
  - LeetCode
  - JavaScript
  - 初级算法
cover: /images/ai.jpg
---

# LeetCode 算法题解集锦

## 目录

- [数组算法](#数组算法)
- [字符串算法](#字符串算法)
- [链表算法](#链表算法)
- [树结构算法](#树结构算法)
- [动态规划](#动态规划)

## 数组算法

### 题目列表

#### 旋转图像

```javascript
// 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
// 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
// 输入：matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
// 输出：[[7, 4, 1], [8, 5, 2], [9, 6, 3]]
function rotate(matrix) {
  const n = matrix.length;

  // 步骤1：沿对角线翻转
  for (let i = 0; i < n; i++) {
    for (let j = i; j < n; j++) {
      // 交换matrix[i][j]和matrix[j][i]
      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
    }
  }

  // 步骤2：左右翻转
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n / 2; j++) {
      // 交换matrix[i][j]和matrix[i][n-1-j]
      [matrix[i][j], matrix[i][n - 1 - j]] = [
        matrix[i][n - 1 - j],
        matrix[i][j],
      ];
    }
  }

  return matrix;
}

console.log(
  rotate([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
  ])
);
```

#### 寻找最大值

```javascript
// 给定一个数组，返回数组中的最大值
function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}

console.log(findMax([1, 3, 5, 7, 9])); // 输出：9
```

#### 反转数组

```javascript
// 给定一个数组，反转数组中的元素
function reverseArray(arr) {
  let left = 0;
  let right = arr.length - 1;
  while (left < right) {
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
  return arr;
}

console.log(reverseArray([1, 2, 3, 4, 5])); // 输出：[5, 4, 3, 2, 1]
```

#### 两数之和

```javascript
// 给定一个整数数组 nums 和一个目标值 target，返回数组中和为目标值的两个数的索引。
function twoSum(nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
  return [];
}

console.log(twoSum([2, 7, 11, 15], 9)); // 输出：[0, 1]
```

## 字符串算法

#### 反转字符串

```javascript
// 给定一个字符串，反转字符串中的字符
function reverseString(str) {
  return str.split("").reverse().join("");
}

console.log(reverseString("hello")); // 输出："olleh"
```

#### 判断回文

```javascript
// 给定一个字符串，判断其是否为回文
function isPalindrome(str) {
  const cleanedStr = str.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
  return cleanedStr === cleanedStr.split("").reverse().join("");
}

console.log(isPalindrome("A man, a plan, a canal: Panama")); // 输出：true
```

#### 字符串包含

```javascript
// 判断字符串 s 是否包含字符串 t
function contains(s, t) {
  return s.includes(t);
}

console.log(contains("hello world", "world")); // 输出：true
```

## 链表算法

### 题目列表

#### 反转链表

```javascript
// 给定一个链表，反转链表并返回反转后的链表头节点
function ListNode(val) {
  this.val = val;
  this.next = null;
}

function reverseList(head) {
  let prev = null;
  let current = head;
  while (current) {
    const nextTemp = current.next; // 保存下一个节点
    current.next = prev; // 反转当前节点的指针
    prev = current; // 移动prev指针
    current = nextTemp; // 移动到下一个节点
  }
  return prev; // 返回新的头节点
}

// 示例用法
const head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
const reversedHead = reverseList(head);
```

#### 合并两个有序链表

```javascript
// 合并两个有序链表并返回合并后的新链表
function mergeTwoLists(l1, l2) {
  const dummy = new ListNode(0);
  let current = dummy;

  while (l1 && l2) {
    if (l1.val < l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }
    current = current.next;
  }

  current.next = l1 || l2; // 连接剩余部分
  return dummy.next; // 返回合并后的链表头
}
```

## 树结构算法

### 题目列表

#### 二叉树的前序遍历

```javascript
// 给定一个二叉树，返回其节点值的前序遍历
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

function preorderTraversal(root) {
  const result = [];
  function traverse(node) {
    if (!node) return;
    result.push(node.val); // 访问根节点
    traverse(node.left); // 遍历左子树
    traverse(node.right); // 遍历右子树
  }
  traverse(root);
  return result;
}

// 示例用法
const root = new TreeNode(1);
root.right = new TreeNode(2);
root.right.left = new TreeNode(3);
console.log(preorderTraversal(root)); // 输出：[1, 2, 3]
```

#### 二叉树的层序遍历

```javascript
// 给定一个二叉树，返回其节点值的层序遍历
function levelOrder(root) {
  const result = [];
  if (!root) return result;

  const queue = [root];
  while (queue.length) {
    const level = [];
    const size = queue.length;
    for (let i = 0; i < size; i++) {
      const node = queue.shift();
      level.push(node.val);
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    result.push(level);
  }
  return result;
}
```

## 动态规划

### 题目列表

#### 爬楼梯

```javascript
// 假设你正在爬楼梯。需要 n 阶台阶，你可以一次爬 1 阶或 2 阶。计算有多少种不同的方法可以爬到顶部。
function climbStairs(n) {
  if (n <= 2) return n; // 基础情况
  let first = 1,
    second = 2;
  for (let i = 3; i <= n; i++) {
    const temp = first + second; // 当前阶梯的方法数
    first = second; // 更新第一步
    second = temp; // 更新第二步
  }
  return second; // 返回到达第 n 阶的方法数
}

console.log(climbStairs(5)); // 输出：8
```

#### 最长公共子序列

```javascript
// 给定两个字符串，返回它们的最长公共子序列的长度
function longestCommonSubsequence(text1, text2) {
  const m = text1.length;
  const n = text2.length;
  const dp = Array(m + 1)
    .fill(0)
    .map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }
  return dp[m][n];
}

console.log(longestCommonSubsequence("abcde", "ace")); // 输出：3
```
