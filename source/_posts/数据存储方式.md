---
title: 数据存储方式
date: 2020-07-01 15:31:48
---

小小抄 数组的存储方式主要为数组和链表 散列表通过散列函数吧键映射到一个大数组中，不过需要考虑解决散列冲突树用数组实现就是堆，因为堆是一个完全二叉树，用数组存储不需要节点指针。

用链表表示，会衍生出巧妙的设计，比如二叉搜索树，avl树，红黑树 数组的优点: 可以随机访问，通过索引快速找到对应元素，相对而言，链表不支持随机访问，也就是通过索无法快速找到对应元素，主要因为链表需要通过顺序访问，通过前驱或者后继去依次访问表内元素。

链表的优点: 不需要考虑扩容，方便插入和删除元素，如果知道某一个元素的前驱和后驱，插入和删除的时间复杂度就是o() 何为动态规划 动态规划问题的一般形式是求最值，求解动态规划的核心是穷举 重叠子问题，最优子结构，状态转移返程就是动态规划三要素 方法论： 明确base case。

明确状态，明确选择，定义数组或者函数的含义斐波那契数列 暴力递归(什么是递归，是重复调用函数自身来实现循环，迭代是函数内部某段代码实现循环，迭代中当前循环的结果会作为下次循环的初始值) 代码低效，主要原因在于出现大量的重复计算，比如f() = f()+f(),f() = f()+ f(), f() 会被算两次，后面其他数字也是重复计算，这还只是f()，如果是更加大的数值，那么计算量会非常庞大。

这个也就是 重叠子问题 递归算法的时间复杂度是子问题的个数乘以一个子问题需要的时间，所以子问题的个数为 ^n ,子问题时间的话，是 o() 因为就一个加法int fib(int N) { if (N ==  || N == ) return ; return fib(N - ) + fib(N - );} 优化算法，带备忘录的递归算法 最终的时间复杂度为o(n) 这个和动态规划的解法也差不多了， 这个是自顶向下，动态规划一般是自底向上int fib(int N) { if (N < ) return ; // 备忘录全初始化为  vector<int> memo(N + , ); // 进行带备忘录的递归 return helper(memo, N);}int helper(vector<int>& memo, int n) { // base case if (n ==  || n == ) return ; // 已经计算过 if (memo[n] != ) return memo[n]; memo[n] = helper(memo, n - ) + helper(memo, n - ); return memo[n];}
