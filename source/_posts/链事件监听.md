---
title: 链事件监听
date: 2024-12-20 22:38:15
tags: 
  - Blockchain
  - Web3
  - Etherjs
categories:
  - Blockchain
  - Development
---

## 实现方式

### 使用 ethers.js 监听事件

在区块链开发中，事件监听是一个非常重要的功能。虽然轮询也是一种可行的方案，但存在两个主要问题：
1. 实时性差，无法及时响应链上事件
2. API 资源消耗大，频繁的轮询会增加系统负载

> <span style="color: red; font-weight: bold;">注意</span>
> 如果确实需要使用轮询方式，可以通过 NestJS 的 cron 定时任务来实现 queryFilter，但从实践经验来看，事件监听是更优的选择。

### Provider 的选择与实现

在实现事件监听时，Provider 的选择至关重要。以下是两种常见的实现方式：

#### 1. 简单的 JsonRpcProvider
```typescript
const provider = new ethers.JsonRpcProvider(rpcAddress)
```
这种方式实现简单，但在长期监听场景下可能会出现连接不稳定的问题。特别是在轮询模式下，由于每隔固定时间（如60s）会重新执行函数并获取新的 provider，这个问题不太明显。

#### 2. WebSocket Provider 实现
为了解决连接稳定性问题，推荐使用 WebSocket 方式，它支持自动重连机制：

```typescript
async getWebSocketProvider() {
    try {
        // 复用已存在的连接
        if (UtilityService.wsProvider) {
            return UtilityService.wsProvider
        }

        const rpcAddress = this.configService.get('CONTRACT_ADDRESS_RPC')
        if (!rpcAddress) {
            throw new Error('CONTRACT_ADDRESS_RPC not configured')
        }

        // 协议转换
        let wsAddress = rpcAddress
        if (rpcAddress.startsWith('http://')) {
            wsAddress = rpcAddress.replace('http://', 'ws://')
        } else if (rpcAddress.startsWith('https://')) {
            wsAddress = rpcAddress.replace('https://', 'wss://')
        }

        UtilityService.wsProvider = new ethers.WebSocketProvider(wsAddress)
        return UtilityService.wsProvider
    } catch (error) {
        this.logger.error('Failed to create WebSocket provider:', error)
        throw error
    }
}
```

### 事件监听实现

下面是一个实际的事件监听实现示例：

```typescript
private async setupBoxPreOpenListeners() {
    const provider = await this.utilityService.getWebSocketProvider()
    let boxManagerAddress = this.configService.get('xxxxx')
    let boxManagerContract = new ethers.Contract(boxManagerAddress, [
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": false,
                    "internalType": "address",
                    "name": "user",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "address",
                    "name": "user2",
                    "type": "address"
                }
            ],
            "name": "OpenEvent",
            "type": "event"
        },
    ], provider)
    
    // 监听开箱事件，这里在所有inputs参数都获取完成后，可以获取event对象
    boxManagerContract.on('OpenEvent', async (_account,_account2, event) => {
        let account = String(_account)
        let transactionHash = String(event.log.transactionHash)
        // 处理事件逻辑
        xxxxxx
    })
}
```

## 开发经验总结

在区块链服务开发过程中，有以下几个关键点需要特别注意：

1. **稳定性考虑**
   - 区块链服务相比传统业务服务更容易受到外部因素影响
   - GAS 费用波动可能导致交易失败
   - 网络拥堵时可能影响交易执行

2. **错误处理**
   - 必须做好完善的 try-catch 异常处理
   - 实现合理的重试机制
   - 通常建议在命令之间添加适当的延时（如10s）

3. **代码组织**
   - 合约相关功能最好进行封装
   - 封装有利于实现统一的重试机制
   - 每次完整执行合约初始化，可以减少 nonce 重复问题

通过以上实践，可以构建更稳定可靠的区块链服务。